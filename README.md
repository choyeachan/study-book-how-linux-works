# 리눅스 작동법

![bookcover](./img/book-cover.jpg)

---
## 목차 

[1장. 조감도](#1장-조감도)

[2장. 기본 명령어와 디렉터리 계층 구조](#2장-기본-명령어와-디렉터리-계층-구조)

[3장. 디바이스](#3장-디바이스)

4장. 디스크와 파일 시스템

5장. 리눅스 커널 부팅 방법

6장. 사용자 공간 시동 방법

7장. 시스템 설정: 로깅, 시스템 시간, 일괄 작업과 사용자

8장. 프로세스와 리소스 활용

9장. 네트워크와 그 설정에 대한 이해

10장. 네트워크 응용프로그램과 서비스

11장. 셸 스크립트 소개

12장. 네트워크를 거쳐 파일 옮기기

13장. 사용자 환경

14장. 리눅스 데스크톱에 대한 조망

15장. 개발 툴

16장. C 소스 코드로 소프트웨어 컴파일하는 기본적인 방법

17장. 기초를 바탕으로 길제 구축하기

---
## 1장. 조감도

- 운영체제가 동작하는 방법을 추상(abstraction)으로 이해하자
    - 추상? 대부분의 상세 부분을 무시하는 것

### 1.1 리눅스 시스템의 추상화 레벨과 레이어

- 레이어(layer) or 레벨(level)
    - 해당 구성요소가 사용자와 하드웨어 사이의 어디에 위치하는지에 따라 구성요소를 구분(그룹으로 분류)하는 것

- 리눅스 시스템 세가지 주요 레벨
    ![리눅스레벨](./img/1/linux_level.png)

- 커널과 사용자 프로세스 동작 방식 차이점
    - 커널 
        - 커널 모드(kernel mode)에서 동작
        - 프로세서나 주기억 장치에 제한 없이 접근 가능
        - 커널 공간(kernal space)
            - 커널만 접근 가능한 영역
    - 사용자 프로세스
        - 사용자 모드(user mode)에서 동작
        - (아주 적은) 메모리 공간의 일부와 안전한 CPU작업에만 접근할수 있도록 제한됨
        - 사용자 공간
            - 사용자 프로세스가 접근할 수 있는 주기억 공간의 일부
        - 만약 프로세스가 실수하더라도 결과가 제한적이고 커널에서 해결 가능

### 1.2 하드웨어: 주기억 장치에 대한 이해

- 주기억 장치(main memory)
    - 0과 1(비트)들을 위한 커다란 저장 공간(집합체)
    - 실행 중인 커널과 프로세스가 상주하는 공간
    - 주변 장치의 모든 입출력이 비트 묶음의 형태로 주기억 장치로 흘러들어가게 됨

- CPU
    - 메모리상의 운영자
    - 명령들과 메모리의 데이터를 읽고 메모리에 다시 데이터를 기록

- 상태(state)
    - 비트의 특정한 배열
        - 예시) 메모리에 4비트 -> 0110,0001,1011 세가지 다른 종류의 상태를 표현함
    - 상태에 대해 추상적 용어를 사용
        - 비트를 사용하여 상태를 묘사하는 것이 아니라 어떤 것이 무엇을 했는지, 그 순간 어떤 동작을 하고 있는지를 묘사
        - 단 하나의 프로세스가 메모리에서 수백만의 비트로 구성되기 때문에 추상적 용어 사용이 더 쉬움 

### 1.3 커널

- 커널이 실행하는 거의 모든 작업은 주기억 장치를 위주로 진행
- 커널은 메모리를 여러 개의 구획으로 분리하고, 구획에 대한 상태 정보를 항상 보유해야함
- 각 프로세스는 메모리에 각자의 구획을 갖고, 커널은 각 프로세스가 각각의 구획을 유지를 하는지 확인

- 커널의 유지 책임(아래 네가지 일반 시스템 영역내 작업 유지)
    - 프로세스 
        - 커널은 어떤 프로세스가 CPU의 사용을 허용받았는지 알고 있어야 함 
    - 메모리 
        - 커널은 모든 메모리를 지속적으로 파악해야함
            - 현재 특정 프로세스에 할당된 메모리가 무엇인지
            - 프로세스 간 공유할 수 있는 메모리는 무엇인지
            - 할당되지 않은 것은 무엇인지
    - 장치 드라이버
        - 커널은 (디스크와 같은) 하드웨어와 프로세스 사이의 인터페이스로 동작
        - 하드웨어를 운영하는 것은 커널의 일
    - 시스템 콜과 지원
        - 프로세스는 보통 커널과 소통을 하는데 시스템 콜(system call)을 사용

#### 1.3.1 프로세스 관리

- 프로세스의 시작, 멈춤, 재개와 종료에 대한 것
- 문맥 전환(context switch)
    - 하나의 프로세스가 다른 프로세스를 위해 CPU에 대한 제어를 포기하는 행위
    - 유저입장에서는 프로세서들이 동시에 실행하는 것처럼 보이지만, 1개 코어로 실행할 경우 1초보다 짧은 시간 동안 CPU를 사용한 후 멈추고, 다른 프로세스가 CPU를 사용함
    - 커널이 책임짐
- 타임 슬라이스(time slice)
    - 각 시간의 조각
    - 중요한 연산을 하기에 충분한 시간을 프로세스에 부여
    - 조각들이 너무 작기 때문에 동시에 다수의 프로세스를 실행 하는것 처럼 보임(다중 작업 처리-multitask 능력)
- 문맥전환의 흐름
    1. CPU(실질적 하드웨어)는 내부 타이머를 기초로 하여 현재 프로세스를 중단하고 커널 모드로 전환. 그리고 커널에 통제권을 넘김
    2. 커널은 CPU와 메모리의 현재 상태를 기록. (방금 중지된 프로세스를 다시 재개하는데 필수적)
    3. 커널은 이전 타임 슬라이스 동안 발생해야 했던 작업들을 실행(입출력,여러 활동등으로부터 데이터를 수집하는 등의 작업)
    4. 커널은 다른 프로세스가 동작할 수 있도록 준비. 커널이 실행할 준비가 된 프로세스 목록을 분석하고 하나를 선택
    5. 커널은 이 새로운 프로세스를 위한 메모리 준비. 이어서 CPU 준비시킴
    6. 커널이 새로운 프로세스를 위한 타임 슬라이스가 얼마나 걸릴 것인지 CPU에게 알림
    7. 커널이 사용자 모드로 CPU를 전환하고, CPU 통제권을 프로세스에 넘김
- 커널은 문맥전환이 이뤄지는 동안 프로세스의 타임 슬라이스 사이 사이에 실행됨
- 다수의 CPU를 갖춘 시스템의 경우 좀더 복잡(현재 CPU에 대한 통제권을 커널이 포기할 필요가 없기 때문)

#### 1.3.2 메모리 관리

- 커널은 문맥 전환이 이뤄지는 동안 메모리를 관리하는 복잡한 작업 수행
- 수행 조건
    - 커널은 사용자 프로세스가 접근할 수 없는 전용 영역을 메모리 안에 보유하고 있어야 한다
    - 각 사용자 프로세스는 자신만의 메모리 구역이 있어야 한다
    - 하나의 사용자 프로세스는 다른 프로세스의 전용 영역에 접근할수 없다
    - 사용자 프로세스들은 메모리를 공유할 수 있다
    - 사용자 프로세스에서 일부 메모리는 읽기 전용이 될 수 있다.
    - 시스템은 보조로 디스크 공간을 사용함으로써 물리적으로 존재하는 것보다 더 많은 메모리를 사용할 수 있다
- 가상 메모리(virtual memory) 라고 하여 메모리 접근을 계획할수 있게 해주는 메모리 관리 유닛(memory management unit, MMU)을 포함
- 커널은 각각의 프로세스가 머신(machine) 전체를 점유하고 있는 것처럼 동작하도록 해당 프로세스를 설정
    - 프로세스가 메모리의 일정 부분에 접근할 때 MMU는 그 접근을 가로채서 메모리 어드레스 맵(ememory address map, 메모리 주소 지도)을 사용하여 프로세스의 메모리 위치를 머신상의 실질적인 물리적 메모리 위치로 변환시킴
    - 커널은 여전히 이 메모리 어드레스 맵을 초기화시키고 지속적으로 유지하며 변경해야함

#### 1.3.3 장치 드라이버와 관리

- 보통 커널 모드에서만 접근 가능 (부적절한 접근으로 머신에 손상이 올수 있기 때문에)
- 장치 드라이버는 전통적으로 커널 영역(같은 장치라도 동일한 프로그래밍 인터페이스 갖는 경우가 드물기 때문)
- 장치 드라이버들은 SW 개발자들의 작업을 단순화하기 위해 사용자 프로세스에 동일한 인터페이스를 제공하기 위해 노력중

#### 1.3.4 시스템 호출과 지원

- 시스템 콜은 사용자 프로세스 단독으로는 잘할 수 없거나 전혀 할수 없는 특정한 작업을 수행
- 파일 읽고 쓰는 기능은 모두 시스템 콜과 관련

- fork()
    - 프로세스가 fork()를 호출할 때 커널은 프로세스와 거의 일치하는 복사본을 만들어낸다.
- exec()
    - 프로세스가 exec(program)를 호출할 때 커널은 program을 시작하여 현재 프로세스를 대신한다.

- 리눅스 시스템상의 모든 사용자 프로세스는 fork()의 결과로 시작
- 대다수의 경우 기존 프로세스의 복사본을 실행하지 않고 exec()를 실행하여 새로운 프로그램을 시작

- 예시(명령어 ls 실행)
    ![새로운 프로세스의 시작](./img/1/fork_exec.png)
    
    1. 터미널 윈도우에 ls를 입력한다면 윈도우 내부에서 실행되고 있는 셸이 fork()를 호출 -> 셸의 복사본 생성
    2. 셸의 새로운 복사본이 exec(ls)를 호출하여 ls 실행 

- 의사 장치(pseudodevices)
    - 커널은 전통적인 시스템 호출이외의 기능을 통해 사용자 프로세스들을 지원, 의사 장치는 그 중 하나
    - 사용자 프로세스의 입장에서는 장치처럼 보여짐
    - 실제로는 순전히 소프트웨어로 구현됨
    - 예시
        - 커널 난수(random number) 생성장치(/dev/random)
    - 기술적으로 의사 장치에 접근하는 사용자 프로세스는 여전히 장치를 여는 데 시스템 콜을 사용해야함. 피할 수 없음

### 1.4 사용자 공간

- 커널이 사용자 프로세스에게 할당하는 주요 메모리
- 프로세스 타입과 상호작용
![프로세스 타입과 상호작용](./img/1/user_interface.png)
    - 상위레벨
        - 사용자와 가장 가까운 레벨
        - 사용자들이 직접 제어하는 복잡한 작업 수행
    - 중위레벨
        - 하위 레벨보다 좀 더 큰 요소를 포함
        - 메일, 프린트, 데이터베이스 서비스
    - 하위레벨 :
        - 커널과 가까운 레벨 
        - 단순 작업, 복잡하지 않은 작업 수행 요소들로 구성
        - 네트워크 구성, 커뮤니케이션 버스...
- 일부 사용자 공간 요소들은 분류하기 어려움(작업이 복잡해서)
    - 웹, 데이터베이스 서버

### 1.5 사용자

- 리눅스 커널은 유닉스 사용자에 대한 전통적인 개념을 지원
- 사용자(user)
    - 프로세스들을 실행할 수 있고 파일들을 소유할 수 있는 독립체
    - 사용자 이름(username)과 관련 있음
    - 사용자 ID(userid)
        - 단순한 숫자로 구성된 식별자 
- 접근 권한과 한계를 지원하기 위해 존재
- 모든 사용자 공간 프로세스는 owner 라는 사용자를 갖고 있고, 프로세스들은 owner로써 실행된다
    - 소유 프로세스의 행동을 종료, 수정 가능
    - 단, 다른 사용자의 프로세스 방해는 할 수 없음
    - 파일 소유, 다른 사용자들과 파일들을 공유할것인지 선택가능
- root
    - 다른 사용자의 프로세스를 종료시키고 변경할 수 있음
    - 슈퍼 사용자(superuer) 라고 불림
    - 루트로 운영할 수 있는 사람에 대해 루트 접근 권한을 가지고 있다고 말함
    - 전통적 유닉스 시스템상에서 관리자(administrator) 라고 함
- 그룹(groups)
    - 다수의 사용자들로 구성된 세트
    - 목적
        - 사용자가 그룹 내의 다른 사용자들과 파일 접근을 공유할수 있도록 하려는 것

----
## 2장. 기본 명령어와 디렉터리 계층 구조

- 리눅스는 유닉스에서 파생 된 변종. 
    - 이번 장에서 배운 것들은 다른 변종 유닉스 시스템에서도 사용이 가능 하므로 유닉스 명령어라고 정의
---
### 2.1 본 셸(Bourne Shell): /bin/sh
---
- 셸은 사용자가 입력하는 명령어들을 실행하는 프로그램으로 가장 중요한 부분 중 하나이다.
- 셸 스크립트(shell scripts)는 일련의 셸 명령어들을 포함하고 있는 텍스트 파일을 일컫는다.
- 여러가지 다른 유닉스 셸들이 존재하지만 모두 본 셸(/bin/sh)에서 여러 가지 기능들이 파생됨.
- 본 셸은 벨 연구소에서 초기 유닉스 버전을 위해 개발 됨.
- 리눅스의 경우 bash(bourne again shell)이라고 불리우는 보강된 본 셸 버전을 default 사용한다.
    - /bash/sh 보통 리눅스 시스템상의 bash로 연결되는 링크.
---
### 2.2 셸 활용
---
#### 2.2.1 셸 윈도우

- 프롬프트는 운영 체제 마다 다름
    -  우분투 name@host:path$ 페도라 계열 \[name@host path\]$
- 슈퍼 사용자(root)로 로그인 시 #으로 시작되며, 일반 사용자는 $로 표시 됨. 

#### 2.2.2 cat

- cat은 concatenation(연속적인)의 약자로 cat file1 file2를 사용하게 되면 단순히 file1, file2의 내용을 연이어 출력함.

#### 2.2.3 표준 입력과 표준 출력

- 유닉스 프로세스는 데이터를 읽고 쓰는 데 입출력 스트림(I/O stream)을 사용한다. 
    - 스트림은 매우 융통성이 있어서 입력 스트림의 출처가 파일, 장치 또는 터미널이 될 수 있으며, 다른 프로세스의 출력 스트림이 될 수 있다. ex) ps -ef | grep 
- cat
    - cat의 경우 아무 명령어를 입력 하지 않으면 표준 입력 스트림으로부터 데이터를 읽게 되는데, 표준 입력은 터미널에 연결된다.
    - cat 명령은 출력을 항상 표준 출력(터미널)로 내보낸다.
    - 표준 입력과 출력은 stdin, stdout의 축약어로 부르기도 한다.
---
### 2.3 기본 명령어
---
#### 2.3.1 ls

- ls 명령은 디렉터리의 콘텐츠를 열거하는 명령이다. (default는 현재 디렉터리)
    - > $ ls -l
        - 상세한 목록을 보여준다.
    - > $ ls -F
        - 파일 타입정보를 보여주게 된다.

#### 2.3.2 cp

- cp는 파일을 복사하는 명령어이다.
    - > $ cp file1 file2
        - file1을 file2로 복사한다.
    - > $ cp file1 file2 ... fileN dir 
        - dir이라는 디렉터리에 file들을 복사한다.

#### 2.3.3 mv

- mv(move) 명령은 cp와 비슷하며 파일을 이동시키는(파일명을 바꾸는) 명령어이다.
    - > $ mv file1 file2
        - file1의 이름을 file2의 이름으로 바꾼다.
    - > $ mv file1 ... fileN dir
        - dir이라는 디렉터리에 file들을 옮긴다.

#### 2.3.4 touch

- touch 명령은 파일을 생성하는 명령이다. 
- > $ touch file
    - 파일이 이미 존재
        - ls -l 명령으로 출력되는 파일의 수정 시간 기록을 업데이트
    - 파일이 존재하지 않음
        - 빈 파일을 생성한다.
> $ ls -l file <br> -rw-r--r-- 1 juser users <u>0 May 21 18:32</u> file

#### 2.3.5 rm

- rm은 파일을 삭제하는 데 활용 된다. 파일을 삭제한 후에는 되살릴 수 없다.
    - > $ rm file

#### 2.3.6 echo

- echo 명령은 표준 출력으로 인수들을 출력한다.
    - > $ echo Hello again. <br> Hello again.
---
### 2.4 디렉터리 탐색
---
- 유닉스는 /에서 시작되는 디렉터리 계층 구조를 갖고 있다 이것을 **루트 디렉터리** 라고 부른다.

    - 디렉터리의 구분자는 역슬래시(\\)가 아니고 슬래시(/)임에 주의.

- /로 경로가 시작 된다면 전체, 절대 경로이다.

- ..은 그 디렉터리의 부모의 디렉터리를 의미한다.
    - 현재 위치가 **/usr/lib**라면 ../는 /usr를 의미하며 ../bin은 /usr/bin을 의미한다.

- . (점 하나)은 현재 디렉터리를 의미한다. 
    - 경로가 /로 시작되지 않는다면 대부분의 명령어들은 현재 디렉터리를 디폴트로 하기 때문에 자주 사용하지 않는다.

- /로 시작되지 않는 경로를 상대 경로라고 한다.

#### 2.4.1 cd

- 현재 작업 중인 디렉터리를 변경하는 명령어이다.
- cd만 입력 시 홈 디렉터리로 돌아간다.
    - > $ cd dir

#### 2.4.2 mkdir

- mkdir 명령은 새로운 디렉터리를 생성한다.
    - > $ mkdir dir

#### 2.4.3 rmdir

- rmdir 명령은 디렉터리 dir을 삭제한다.
- dir이 비어있지 않다면 명령이 실패하며 이 경우 rm -rf dir을 사용하면 디렉터리와 그 내용을 삭제 할 수 있다.
    - > $ rmdir dir
    - > $ rm -rf dir

#### 2.4.4 셸 글로빙(와일드 카드)

- 셸은 파일과 디렉터리 이름에 간단한 패턴들을 대응 시킬 수 있는데. 이런 과정을 **글로빙(globbing)** 이라고 한다.
- 셸은 글로브를 포함하는 인수들을 파일 이름에 대응시켜서 그 인수들을 파일 이름들로 대체한 다음, 수정된 명령줄을 실행한다. 대체하는 것을 **확장(expansion)** 이라고 부른다.
- 글로브와 일치하는 파일이 없다면 명령은 *처럼 문자 그대로의 부호로 인식하고 실행한다.
- ?(물음표)는 한 가지 임의의 문자를 대응한다. ex) b?at -> boat, brat와 일치
- ''로 감싸면 글로빙이 아닌 문자 그대로를 인식한다 ex) echo '*'
---
### 2.5 중급 명령
---
#### 2.5.1 grep

- grep 명령은 표현과 일치하는 파일이나 입력 스트림의 라인들을 출력한다.
    - > $ grep root /etc/*
        - root 라는 단어를 포함하고 있는 /etc안의 모든 파일들을 확인한다
        - 자주 쓰이는 옵션에는 -i(대/소문자를구별하지 않는 경우), -v(검색 결과를 뒤바꾸는, 즉 일치하지 않는 모든라인을 출력하는 경우)
    - egrep의 경우 grep -E와 같다
        - 더 많은 확장 정규 표현식을 사용하기 위한 명령어이다.
    - .*는 어떤 문자와도 일치할 수 있다. (와일드카드와 같다)
    - .은 한 가지 임의 문자와 일치한다.

#### 2.5.2 less

- less 명령은 파일이 아주 크거나 명령에 대한 출력 내용이 너무 길어 화면 상단으로 스크롤되어 넘어가는 경우에 아주 편리하게 활용할 수 있다.
- less 내부에서 텍스트를 검색할 수도 있다. (정방향 - /word 역방향 - ?word )
- 리눅스에서는 프로그램의 표준 출력을 다른 프로그램의 표준 입력으로 보낼수 있는데 다른 프로그램의 표준 출력을 less로 보내 출력 내용을 보면 매우 유용하다.
- 다음 예제는 grep 명령의 출력 결과를 less로 보내는 명령이다.
    - > $ grep ie /usr/share/dict/words | less

#### 2.5.3 pwd

- pwd(print working directory) 프로그램은 현재 작업 중인 디렉터리의 이름을 출력한다.
- 심볼릭 링크는 때로 현재 작업 중인 디렉터리의 전체 경로를 모호하게 만들 수 있는데. 이런 혼란을 제거하기 위해 pwd -P(physical)를 사용 할 수 있다. 실제 경로가 출력된다.

#### 2.5.4 diff

- 두 개의 텍스트 파일들 간의 차이점을 알고 싶다면 diff를 사용할 수 있다.
```
$ diff file1 file2
3c3
< walnuts
---
> grapes
```

#### 2.5.5 file

- 리눅스 명령어 file은 파일의 종류 확인 및 파일 속성 값을 확인할때 사용하는 명령어다. 주로 acsii나 text, date와 같은 파일 속성을 출력하는데, /usr/share/magic이나 /usr/lib/magic에 저장한 파일 정보를 참고하여 파일 속성을 출력한다.
- > $ file filename

#### 2.5.6 find와 locate

- find 명령은 어떤 특정 파일이 디렉터리 트리 중 어딘가에 있는지를 알아 낼 때 유용하게 사용한다.
- locate 명령은  검색DB(파일 목록 데이터베이스)를 미리 생성하기 때문에 속도가 빠르다. 미리 만들어 놓은 DB파일에서 파일을 검색하기 때문에 최근에 삭제된 파일도 검색이 되는 문제가 발생하게 되므로 locate 명령어를 사용하기 전에 색인을 업데이트 해야함(updatedb)

#### 2.5.7 head와 tail

- head는 파일의 처음 10줄을 보여주며 tail은 마지막 10줄을 보여준다.
- -n 옵션으로 화면에서 보기 원하는 라인의 개수를 변경 할 수 있다.

#### 2.5.8 sort

- sort 명령은 텍스트 파일의 라인들을 글자와 숫자의 순서에 따라 빠르게 정렬시킨다.
- -r 옵션은 순서를 반대로 정렬하며 숫자에 따라 순서대로 정리하고 싶다면 -n 옵션을 사용한다.
- > $ cat /etc/passwd | sort -r
---
### 2.6 비밀번호와 셸 변경하기
---
- passwd 명령을 사용하여 비밀번호를 변경할 수 있다. 이전 비밀번호를 먼저 요구한 다음, 이어서 새로운 비밀번호를 두 번 입력한다.
---
### 2.7 Dot Files
---
- .bashrc .login등의 파일
- 도트 파일은 일반 ls명령어에 옵션 -a를 주어야 볼수 있다.
- 셸 글로브들은 분명하게 .*와 같은 패턴을 사용하지 않는 한 도트 파일들과 일치하지 않는다.
---
### 2.8 환경 변수와 셸변수
---
- 셸은 셸 변수 라고 불리는 텍스트 문자열의 값을 포함하는 임시 변수들을 저장할수 있다.
- >$ STUFF=blah
- 조회는 $STUFF로 할수 있다
- >$ echo $STUFF

- 환경 변수(environment variables)도 셸 변수와 마찬가지지만 셸에 한정 되지 않으며 운영체제가 셸의 모든 환경변수들을 셸이 실행하는 프로그램으로 전달한다.
- 셸의 export 명령으로 환경 변수를 할당한다.
- >$ export STUFF
---
### 2.9 명령어 path
---
- 명령어 path는 명령어의 위치를 찾으려고 할 때 셸이 검색하는 시스템 디렉터리 목록을 말한다.
- > echo $PATH
    - 경로 구성 요소들은 콜론(:)으로 분리되어 나타난다.
    - 만약 동일한 이름을 가진 프로그램들이 이 경로의 여러 디렉터리 안에서 나타난다면 셸은 맨 처음 일치하는 프로그램을 실행한다.
- PATH 환경변수 추가
    - > PATH=dir:$PATH
---
### 2.10 특수 문자
---

![2-3](./img/2/2-3.jpg)

---
### 2.11 명령줄 편집
---

![2-4](./img/2/2-4.jpg)

---
### 2.12 텍스트 편집 프로그램
---
- vi 또는 emacs이 사실상의 표준이라고 할 수 있다.
---
### 2.13 온라인 도움말
---
- man 명령어를 사용한다. 
- > $ man ls
- 키워드로 매뉴얼 페이지를 검색하려면 -k 옵션을 사용한다
- > $ man -k sort
- GNU 프로젝트는 매뉴얼 페이지를 더 이상 유지하지 않고 info(또는 textinfo)라고 불리는 다른 포맷으로 전환하기로 결정했다. 
---
### 2.14 셸 입력과 출력
---
- 표준 입력과 출력을 리다이렉트(redirect) 하는 방법
- command의 출력을 터미널 대신 파일로 보내려면 > 리다이렉션 문자를 사용
- > $ command > file
    - 셸은 만약 파일이 이미 존재하고 있지 않다면 파일을 생성한다. 파일이 이미 존재하면 셸은 기존의 파일을 지운다.
    - 지우지 않고 파일에 출력을 덧붙이려면 ```>>```를 사용한다

#### 2.14.1 표준 오류

- 표준 오류를 리다이렉트 하려면 ```2>``` 문법을 사용한다.
- > $ ls /ffffffff > f 2> e
    - 숫자 2는 셸이 수정하는 스트림ID를 의미한다.
    - 스트림 ID 1 : 표준 출력
    - 스트림 ID 2 : 표준 오류
- ```\>&``` 표기를 사용하여 표준 오류를 표준 출력과 동일한 장소로 보낼 수도 있다.
    - > $ ls /ffffffff > f 2>&1

#### 2.14.2 표준 입력 리다이렉션

- 파일을 프로그램의 표준 입력으로 보내려면 < 연산자를 사용한다.
- > $ head < /proc/cpuinfo
    - 대부분의 유닉스 명령어들은 파일 이름을 인수로 수용해서 흔하지 않다.
---
### 2.15 오류 메시지 이해
---
#### 2.15.1 유닉스 오류 메시지 분석
```
 $ ls /dsafsda
 ls: cannot access /dsafsda: No such file or directory
```
- 메시지에는 세가지 요소들이 있다.
    - 프로그램 이름은 ls다.
    - 파일 이름, /dsafsda는 좀더 구체적인 정보다. 이 경로에 문제가 있다.
    - No such file or directory라는 오류메시지는 파일 이름에 문제가 있음을 나타낸다.


#### 2.15.2 일반 오류
- 유닉스에서 가장 흔히 나타나는 오류 메시지들이다.
    - 파일 또는 디렉터리가 존재하지 않는다 (No such file or directory)
    - 파일이 존재한다 (File exists)
    - 디렉터리가 아니다 / 디렉터리다(Not a driectory, Is a directory)
        - 파일을 디렉터리 처럼, 반대로 디렉터리를 파일처럼 사용하려고 할 때
    - 장치에 남은 공간이 없다 (No space left on device)
        - 디스크 공간이 꽉 찬 상태라는 것이다.
    - 접근 권한 거부 (Permission denied)
        - 접근이 허용되지 않은 어떤 파일이나 디렉터리를 읽거나 쓰려는 시도를 할 때
    - 작업이 허용되지 않는다 (operation not permitted)
        - 소유하지 않은 프로세르를 죽이려고 할 때 발생한다.
    - 세그먼테이션 결함, 버스 에러 (Segmentation fault, Bus error)
        - 프로그램이 접속이 허용되지 않은 메모리의 일부에 접근하려고 시도할때, 운영체제에 의해 발생
---
### 2.16 프로세스의 목록화 및 조작
---
- 프로세스는 실행 중인 프로그램 이며 숫자로 표현되는 프로세스 ID(PID)를 갖게 된다.
- 실행되고 있는 프로세스들을 빠르게 열거하려면 명령줄에서 ps를 실행하면 된다.

```
$ ps
    PID  TTY  STAT TIME COMMAND
    520   p0  S    0:00 -bash
    545   ?   S    3:59 /usr/X11R6/bin/ctwm -W
    548   ?   S    0:10 xclock -geometry -0-0
    2159  pd  SW   0:00 /usr/bin/vi  lib/addresses
    31956 p3  R    0:00 ps
```

- 다음은 각 필드에 대한 설명이다:
    - ```PID``` 프로세스 ID.
    - ```TTY``` 프로세스가 동작하고 있는 터미널 장치.
    - ```STAT``` 프로세스의 상태
    - ```TIME``` 프로세스가 지금까지 사용했던 CPU 시간을 분과 초로 나타낸다. (해당 프로세스가 프로세서에서 명령들을 실행하는 데 사용한 전체 시간의 양)
    - ```COMMAND``` 명령어이다. (프로세스가 이 필드를 본래 값과 다르게 변경할 수 있다)

#### 2.16.1 명령옵션(BSD 스타일)
- ```ps``` 명령은 유닉스, BSD, GNU 형식이 있다.
- ```ps x``` 동작하고 있는 모든 프로세스들을 보여준다.
- ```ps ax``` 소유하고 있는 프로세스들뿐만 아니라 시스템상의 모든 프로세스들을 보여준다.
- ```ps u``` 프로세스에 대한 좀 더 상세한 정보를 포함시킨다.
- ```ps w``` 한 줄로 맞추는 것이 아니라 전체 명령을 보여준다.

- 특정 프로세스를 확인하려면 ```ps 옵션 PID``` 로 확인한다.

#### 2.16.2 프로세스 죽이기

- > $ kill pid
    - 프로세스를 종료시킨다.
- > $ kill -STOP pid
    - 프로세스를 정지시킨다.
- > $ kill -CONT pid
    - 프로세스를 다시 시작한다.
- kill은 운영체제가 프로세스에게 정리할 수 있는 기회를 주지 않고 강제적으로 메모리로부터 제거한다.

#### 2.16.3 작업 제어
- 셸은 작업 제어(job control)를 지원한다
- 다양한 키스트로크와 명령들을 사용하여 TSTP와 CONT 신호를 프로그램으로 보내는 방식이다.
- 현재 작업을 놔둔 채로 다른 작업을 하려면 CTRL-Z를 사용한다.
- fg를 입력해 foreground로 이동하거나 bg를 입력해 background에서 프로그램을 구동한다.

#### 2.16.4 백그라운드 프로세스
- 프로그램이 실행을 마칠 때까지 셀 프롬프트로 다시 되돌아 오지 않으므로 셸로부터 프로세스를 분리하여 & 기호와 함께 "백그라운드"로 가져갈 수 있다.
- > $ gunzip file.gz &
    - 압축을 푸는 동안 다른 작업을 할 수 있다.
    - 새로운 백그라운드의 PID를 출력하는 것으로 응답된다.
    - 로그아웃을 한 후에도 실랳을 계속하게 될 것이다.
- 백그라운드에 있을 때 표준 입력으로부터 무엇인가를 읽으려고 시도한다면 프로그램은 정지하거나 종료될 것이다.
- 프로그램이 표준 출력또는 표준 오류로 무엇인가 출력한다면 다른 작업을 하고 있을때 예기치 않은 출력을 보게 될 수 있다.

---
### 2.17 파일 모드와 접근 권한
---

- 모든 유닉스 파일은 접근 권한을 갖고 있는데. 이 권한이 파일을 읽거나 쓰고 실행할 수 있는지를 결정하게 된다.
- ls -l을 실행시키면 접근 권한에 관한 정보가 나올 것이다.
```
-rw-r--r-- 1 juser somegroup 7041 Mar 26 19:34 endnotes.html
```

![filemode](./img/2/linux-filemode-config.jpg)
- 첫번째 문자는 파일 타입(file type)이다.
    - 대시(-)는 일반 파일(regular file)을 나타낸다.
    - d는 디렉터리를 의미한다.
- 나머지 부분은 접근 권한에 관한 내용이다
    - 사용자(user), 그룹(group), 기타(other)순서로 나뉜다.
        - ```r``` 은 파일을 읽을수 있다는 의미이다.
        - ```w``` 는 파일을 쓸 수 있다는 의미다.
        - ```x``` 는 파일이 실행이 가능하다는 의미다.
        - ```-``` 는 아무 의미도 없다.
- 어떤 실행 파일들은 x 대신 사용자 접근 권한 목록에 s로 되어 있는데, 이것은 실행 파일이 setuid라는 것을 나타낸다.
- setuid는 프로그램을 실행할 때 파일 소유자가 우리가 아니라 사용자인 것처럼 실행을 한다는 의미이다.
- 많은 프로그램들이 루트로써 실행하는 데 이 setuid 비트를 사용한다.

#### 2.17.1 접근 권한 수정

- 접근 권한을 변경하려면 chmod 명령을 사용한다.
```
$ chmod g+r file
$ chmod o+r file
```
- 그룹(g)과 광범위(other의 o) 읽기 접근 권한을 파일에 더한다.
- 한번에 모두 실행 할 수도 있다.
```
$ chmod go+r file
```

- 숫자로 접근 권한을 변경할 수 있다.
```
$ chmod 644 file
```
- 이것을 절대(absolute) 변경이라고 하는데. 모든 접근 권한 비트가 한 번에 설정 되기 때문이다.
- 1(r),2(w),4(x)
- 디렉터리
    - r : 디렉터리 내의 파일의 목록을 볼 수 있다.
    - w : 디렉터리 내의 파일을 삭제, 수정, 변경 가능하다.
    - x : 디렉터리 안으로 접근할 수 있다.
- umask
    - umask 셸 명령을 통해 디폴트 접근 권한을 명시할 수 있다.
    - 어떤 새로운 파일이든지 사전 정의한 접근 권한 세트를 그 파일에 적용하게 한다.
    - umask 값과 새 폴더 퍼미션 값을 더하면 777이 된다. (예: 022 + 755 = 777)
    - 파일의 경우 실행권한은 모두 빠진다.
    - umask 000
        - 새 폴더: 777
        - 새 파일: 666

#### 2.17.2 심볼릭 링크

- 심볼릭 링크(symbolic link)는 다른 파일이나 디렉터리를 가리키는 파일이다.
```
1rwxrwxrwx 1 ruser users 11 Feb 27 13:52 somedir -> /home/origdir
```
- 만약 이 디렉터리에서 somedir에 접근하려고 한다면 시스템은 /home/origdir을 대신 접근하게 할 것이다.

- target으로 부터 linkname이라는 심볼릭 링크를 생성하려면 ln -s를 사용한다.
```
$ ln -s target linkname
```
- 인수 linkname은 심볼릭 링크의 이름이다. 인수 target은 링크가 가리키는 파일이나 디렉터리의 경로다. -s 플래그는 심볼릭 링크를 나타낸다.
---
### 2.18 파일 보관과 압축
---
#### 2.18.1 gzip

- gzip 프로그램(GNU Zip)은 현재 표준 유닉스 압축 프로그램들 중의 하나다.
- gunzip으로 압축을 해제 할 수 있다.
```
gunzip file.gz
```
- 다시 압축하려면 gzip file을 사용한다.

#### 2.18.2 tar

- 다른 운영체제의 zip 프로그램들과 달리 gzip은 파일들의 아카이브를 생성하지 않는다.
- 즉 이 프로그램은 다수의 파일과 디렉터리를 하나의 파일로 보관하지 않는다.
- 아카이브를 생성하려면 대신 tar를 사용한다.
```
$ tar cvf archive.tar file1 file2 ...
```
- c플래그는 생성 모드(create mode)를 활성화 시킨다.
- v 플래그는 상세한 메시지를 출력하도록 활성화한다. 즉 tar로 하여금 아카이브 안의 파일들과 디렉터리들의 이름을 출력하게 한다.
    - tar 가 진행하고 있는 상황을 출력하는 것을 바라지 않는다면 v 플래그를 생략하면 된다.
- f 플래그는 파일 옵션을 나타낸다. 명령줄에서 f 플래그에 이어 등장하는 인수는 tar가 생성해야 하는 아카이브 파일일 것이다.
    - 이 옵션은 항상 그다음에 파일 이름이 와야한다.
- tar 파일 풀기
    - tar 를 사용하여 .tar 파일을 풀려면 x 플래그를 사용한다.
```
$ tar xvf archive.tar
```
- 이 명령에서 x 플래그는 tar를 추출(unpack, extract) 모드가 되도록 한다.

- Table-of-Contents 모드
    - x플래그 사용 전 t플래그를 사용하면 table-of-contents모드로 .tar파일의 내용을 확인해볼 수 있다.
    - 기본적인 아카이브의 무결성을 확인하고 내부의 모든 파일들의 이름을 출력한다.
    - p 옵션은 umask를 무시하고 아카이브에 명시된 정확한 접근 권한을 얻도록 할수 있다.

#### 2.18.3 압축 아카이브(.tar.gz)

- .tar.gz의 경우 gunzip 해제후 tar 해제를 하도록 한다.
```
$ gunzip file.tar.gz
$ tar xvf file.tar
```

#### 2.18.4 zcat
- 아카이브와 압축 기능을 파이프로 결합 할 수 있다.
```
$ zcat file.tar.gz | tar xvf -
```
- zcat 명령은 gunzip -dc와 같은 명령이다. -d 옵션은 압축을 해제하고, -c 옵션은 그 결과를 표준 출력(여기서는 tar 명령)으로 전송한다.
- zcat는 아주 흔하게 사용되기 때문에 리눅스 tar 버전의 경우 단축키가 있다.
```
$ tar zxvf file.tar.gz
$ tar zcvf file.tar.gz
```
---
### 2.19 리눅스 디렉터리 계층 구조에 대한 필수 사항들
---
![linux-directory-hierarchy](./img/2/linux-directory-hierarchy.jpg)

- ```/bin``` ls와 cp같은 기본적인 유닉스 명령의 대부분을 포함하고 있는 ready-to-run 프로그램을 포함
- ```/dev``` 장치 파일들을 포함한다.
- ```/etc``` 핵심 시스템 설정 디렉터리(core system configuration directory)로써 사용자 비밀번호, 부트, 장치, 네트워킹과 그 외 설정 파일들을 포함한다.
- ```/home``` 일반 사용자들을 위한 개인 디렉터리들을 포함한다.
- ```/lib``` library를 축약한 것이다. 라이브러리에는 정적 라이브러리와 공유 라이브러리가 있다.
- ```/proc``` 일부 커널 매개변수들과 현재 가동 되는 프로세스들에 대한 정보, 통계를 포함하고 있다.
- ```/sys``` 장치와 시스템 인터페이스를 제공한다는 점에서 /proc와 유사하다.
- ```/sbin``` 시스템 실행 파일들을 위한 장소. 일반 유저들은 여기에 요소들을 갖고있지 않다. 루트로 실행
- ```/tmp``` 크게 신경 쓸 필요가 없는 작은 파일이나 임시 파일들을 위한 저장 공간. 어떤 사용자나 사용
- ```/usr``` 이름과 달리 사용자 파일은 전혀 포함되어 있지 않다. 내부는 루트밑의 파일명들과 비슷하다
- ```/var``` 변수 서브디렉터리로써 프로그램들은 이곳에 런타임(runtime)정보를 기록한다. 시스템 로깅, 사용자 트래킹, 캐시 그리고 기타 시스템 파일이 생성하고 관리하는 파일들이 여기에 들어 있다.

#### 2.19.1 기타 루트 하위 디렉터리

- ```/boot``` 커널 부트 로더 파일들을 포함한다. 리눅스의 스타트업 절차의 맨 첫번째 단계와 관련있다.
- ```/media``` 제거가 가능한 미디어를 위한 기본 마운트 지점(attachment point)이다.
- ```/opt``` 추가적인 제 3자 소프트웨어를 포함한다. 많은 시스템들이 /opt를 사용하지 않는다.

#### 2.19.2 /usr 디렉터리

- ```/include``` C컴파일러가 사용하는 헤더 파일들을 보관한다.
- ```/info``` GNU 정보 매뉴얼을 포함한다.
- ```/local``` 관리자가 자신의 소프트웨어를 설치할 수 있는 장소.
- ```/man``` 매뉴얼 페이지들을 포함한다.
- ```/share``` 기능의 손실 없이 다른 종류의 유닉스 머신들과 작업해야 할 파일들을 포함한다.(자주 사용되지 않음)

#### 2.19.3 커널 위치
- 리눅스 시스템에서 커널은 일반적으로 ```/vmlinuz``` 또는 ```/boot/vmlinuz```에 있다. 부트 로더가 이 파일을 메모리로 로딩하고 시스템이 부팅할 때 가동을 시킨다.
- 로딩이 가능한 커널 모듈(loadable kernel modules)는 ```/lib/modules``` 아래에 위치한다.
---
### 2.20 슈퍼 사용자의 명령 실행
---
#### 2.20.1 sudo
- 루트처럼 명령을 실행할 수 있도록 허용한다.
- vipw를 사용하여 /etc/passwd 파일을 편집해 sudo를 사용 할 수 있다. (7장)
```
$ sudo vipw
```
#### 2.20.2 /etc/sudoers
- 시스템은 아무 사용자에게 슈퍼 사용자처럼 명령을 실행하도록 허용하지 않는다. /etc/sudoers에서 권한이 있는 사용자를 설정해야 한다.
```
User_Alias ADMINS = user1, user2

ADMINS ALL = NOPASSWD: ALL

root ALL=(ALL) ALL
```
- user1과 user2에게 비밀번호 입력 없이 루트로서 어떤 명령이든 실행할 수 있는 권한을 부여하고 있다.
- 첫 번째 라인은 ADMINS 사용자 별칭을 두 명의 사용자들로 규정한다.
- 두 번째 라인은 권한을 부여하고 있다. ALL = NOPASSWD: ALL 부분은 ADMINS 별칭의 사용자들이 루트로써 명령을 실행하는 sudo를 사용할 수 있다는 의미이다.
- 두 번째 라인의 첫번째 ALL은 "어떤 호스트이든지" 두 번째 ALL은 "어떤 명령이든지"를 의미한다.
- root ALL = (ALL) ALL은 슈퍼 사용자가 모든 호스트상에서 어떤 명령이든지 실행하는 sudo를 사용할 수도 있다는 의미이다.
- (ALL)은 슈퍼 사용자가 다른 기타 사용자처럼 명령을 실행할 수도 있다는 의미이다.




## 3장. 디바

목표

-	기존 시스템을 관찰하여 sysfs를 통해 커널이 장치 설정 정보를 어떤식으로 제공하는지 살펴볼 것이다 몇가지 가자으 기본적인 운영에 대해 이해 할수 있도록 시스템 상의 장에 대한 정보를 얻는것이다.

3.1 장치파일
------------

-	커널이 장치 I/O 인터펭이스를 사용자 프로세스에 파일처럼 제공한다 이런 장치 파일을 장치 노드(device nodes)라고 한다.
-	일반 파일 처럼 사용할 수 있을 뿐 아니라 어떠한 장치의 경우에는 cat 처럼 표준 프로그램으로 접근할 수도 있다.
-	장치파일들은 /dev 디렉터리에 있다 > $ echo blah blah > /dev/null

위 리다이렉트 출력을 /dev/null 장치파일로 전송하고 있다. 커널에서는 dev/null 장치에 작성된 데이터로 무엇을 할지 결정한다. /dev/null 장치 파일의 경우 커널에서 입력을 무시하고 데이터를 버린다

##### ex) windows에서 휴지통에 파일을 버렸다고 생각하면 된다.

---

> [root@was dev]# ls -al </br> total 0 </br> drwxr-xr-x. 18 root root 2940 Jun 20 23:48 . </br> dr-xr-xr-x. 19 root root 275 Apr 21 00:40 .. </br> crw-------. 1 root root 10, 235 Jun 20 23:48 autofs </br> drwxr-xr-x. 2 root root 80 Jun 20 23:48 block </br> drwxr-xr-x. 2 root root 60 Jun 20 23:48 bsg </br> crw-------. 1 root root 10, 234 Jun 20 23:48 btrfs-control </br> srw-rw-rw-. 1 root root 0 Jun 20 23:48 log </br> brw-rw----. 1 root disk 8, 0 Jun 20 23:48 sda </br>

-	위 명령어의 결과값을 보게 되면 접근권한을 볼 수 있다. 각 라인 시작 문자가 b,c,p,s 라면 해당 파일은 장치이다. 이문자는 각 block, character, pipe, socket을 나타낸다.

### 블록장치

-	프로그램은 고정된 양을 가진 블록장치로부터 데이터에 접근한다. sda1은 블록장치의 일종인 디스크 장치다. 디스크는 아주 쉽게 블록 단위의 데이터로 분리된다.

-	블록장칭의 전체 크기는 고정되어 있고, 색인으로 정리하기 쉽기 때문에 프로세스는 커널의 도움으로 장치 안의 어떤 블록이든 임의로 접근할 수 있다.

### 문자 장치

-	문자 장치는 문자 장치에서 문자를 읽을 수 있거나 문자 장치로 문자를 기록 할 수 있다.

-	문자 장치는 크기를 갖고 있지 않다.

-	읽거나 쓸 때 보통 커널이 장치상에서 일고 쓰는 작업을 수행 한다. 컴퓨터에 직접 연결된 프린터는 문자 장치라고 할 수 있다.

-	커널은 테이터를 장치나 프로세스에 전달한 후에 데이터를 백업하고 재검토 하지 않는다.

### 파이프 장치

-	파이프 장치는 네임드 파이프와 비슷하다. 커널 드라이버 대산 I/O 스트림의 다른 쪽에 또 다른 프로세스를 가지고 있다.

> [네임드 파이프]</p> 한 프로세스의 출력을 다른 프로세스의 입력으로 연결해주는 파이프의 하나로, 파이프의 역할을 하는 파일이 존재하여 이 파일을 통해 데이터가 전달됨

### 소켓 장치

-	소켓은 프로세스간의 소통을 우해 자주 사용되는 특수 목적의 인터페이스이다. 종종 /dev 디렉터리 외부에서 볼수 있다.

-	소켓파일들은 유닉스 도메인 소켓에 해당한다.

> Unix domain socket은 TCP의 소켓과 동일한 API 로 데이타를 주고 받을 수 있는 local file 기반의 소켓입니다.</p> TCP socket 과 차이점은 local host 의 process 간의 통신이므로 속도가 매우 빠르고 메모리 소모가 적다는 장점이 있습니다.

3.2 sysfs장치경로
-----------------

-	/dev 안의 장치 이름은 장치에 대해 약간의 정보를 제공 하지만 많은 정보를 주지 않는다.

-	장치들이 발견되는 순서에 따라서 커널이 장치들을 배정한다.

-	리부팅하는 사이 다른 이름을 갖게 될 수도 있다.

-	리눅스 커널은 장치의 실질적인 하드웨어 속성들을 근거로 연결된 장치들을 일정한 관점으로 불 수 있도록 파일과 디렉터리의 시스템을 통해 sysfs 인터페이스를 제공한다.

-	장치들에 대한 기본 경로는 /sys/device다. <span style="color:blue">/dev/sda</span>에 있는 SATA 하드 디스크는 sysfs서 다음과 같은 경로를 갖게 됩니다.

> /sys/devices/pci0000:00/0000:00:01.1/ata1/host0/target0:0:0/0:0:0:0/block

위의 경로는 <span style="color:blue">/dev/sda</span>에 비교해서 아주 길다.

두 경로는 다른 목적을 가지고 있기 떼문에 비교 할 수 없다.<span style="color:blue">/dev</span> 파일은 사용자 프로세스가 장치를 사용할 수 있도록 하기 위해 존재한다. /sys/devices 경로는 정보를 살피고 장치를 관리 하는 데 사용된다.

---

![3-1](./img/sys.PNG)

---

위 경로는 파일과 서브디렉터리들은 사람보다 주로 프로그램이 읽도록 만들졌다.<span style="color:blue">/dev/sda</span>을 예를 살펴보면, 파일과 서브디렉터리들이 무엇을 포함하고 있는지 알 수 있다. 해당 디렉터리에서 <span style="color:red">cat ./dev</span>를 실행하면 8:0이라는 값을 볼 수 있다. 이것은 <span style="color:blue">/dev/sda</span>의 주장치와 부장치 번호이다.

/sys 디렉털에는 몇가지 단축 키가 있다. <span style="color:blue">/sys/block</span>은 시스템에서 사용이 가능한 모든 블록장치들 포함한다. 그러나 이것은 단지 심볼릭 링크다 <span style="color:red">ls -l /sys/block</span>을 실행하면 sysfs의 진짜 경로가 나온다.

---

$ udevadm info --query=all --name=/dev/sda

---

<span style="color:blue">/dev</span>에 있는 어떤 장치의 sysfs 위치를 찾는 것은 어려울 수가 있다. 경로와 기타 속성이 나타나게 하려면 udevadm 명령을 사용한다.

3.3 dd와 장치들
---------------

dd 프로그램은 블록과 문자 장치들과 함께 동작할 때 굉장히 유용하다. 이 프로그램의 기능은 입력 파일을 스트림에서 읽어 오고, 출력 파일을 스트림으로 작성하는 것이다. 인코딩 전환 작업도 가능하다.

---

$ dd if=/dev/zero of=new_file bs=1024 count=1

---

dd 옵션 포멧은 대부분의 다른 유닉스 명령의 옵션 포멧과 다른 면이 있다. 예전의 IBM 작업 제어 언어 스타일을 기초로 하고 있다. 옵션을 표시하는데 대시(-)를 사용하기 보다 옵션의 이름을 표기하고 값을 등호(=) 기호와 함께 해당 옵션에 설정한다. 위의 예제는 <span style="color:blue">/dev/zero</span>(0바이트의 연속 스트림)로 부터 단 하나의 1024-바이트 블록을 new_file로 복사 하고 있다.

#### dd 옵션

1.	if=file </p> 입력파일. 디폴트는 표준 입력이다.
2.	of=file </p> 출력파일. 디포트는 표준 출력이다.
3.	bs=size </p> 블록 사이즈 dd는 한번에 많은 바이트의 데이터를 일고 작성하게 된다 커다란 데이터 덩어리를 줄이려면 각각 512 바이트, 1024바이트를 의미하는 b와 k를 사용할 수 있다. 위의 예제을 bs=1024가 아니라 bs=1k로 읽을 수 있다.
4.	ibs=size, obs=size </p> 입력과 출력 블록 사이즈. 입력과 출력에 대하여 모두 같은 블록 사이즈를 사용할 수 있다면 bs 옵션을 사용 할 수 있다. 그렇지 않은 경우는 각각 입력과 출력에 대하여 ibs와 obs를 사용한다.
5.	count=num </p> 커다라나 파일로 작업하거나 /dev/zero처럼 끝없이 스트림으로 이어지는 데이터를 제공하는 장치와 함께 작업을 하는 경우, 특정 위치에서 dd를 멈추게 한다. 디스크 공간이나 CPU시간 또는 둘 모드를 낭비 할 수 있기 때문이다. 이때, 커다란 파일이나 장치로부터 작은 조각을 복사하는데 skip 매개 변수와 count를 사용한다.
6.	skip=num </p> 입력 파일이나 스트림에서 첫번째 num 블록들을 건너뛰고 이들을 출력으로 복사하지 않는다.

##3.4 장치 이름 요약 때로는 장치의 이름을 찾기가 어려울 수 있다. 다음 장치의 이름을 찾는 몇가지 방법이다.

-	udevadm을 사용하여 udevd에 대해 질의 한다.
-	/sys 디렉터리에서 장치를 찾아 본다.
-	demesg 명령의 출력이나 커널 시스템 로그 파일을 통해 이름을 추측해본다. 이 출력에서 시스템상의 장치들에 관한 설명이 포함 되어 있을 가능성이 있다.
-	시스템에 이미 알려진 디스크 장치의 경우 mount 명령의 출력을 통해 확인해 볼 수 있다.
-	cat /proc/devices를 실행하여 현재 시스템이 드라이버들을 블록이나 문자 장치들을 확인한다. 각 라인은 숫자와 이름으로 구성되어 있다.

###3.4.1 하드 디스크:/dev/sd\*

리눅스 시스템에 연결된 대부분의 하드 디스크들은 /dev/sda, /dev/sdb/ , 등 sd를 접두어로 가진 장치 이름을 갖는 경우가 많다 이러한 장치들은 전체 디스크를 의미 한다. /dev/sda1, /dev/sda2 처럼 디스크상의 파티션들에 대하여 개별적인 장치 파일을 만든다.

이름의 sd 부분은 스카시(Small Computer System Interface,SCSI) 디스크를 나타낸다. SCSI는 원래 디스크 같은 장치들과 그 외 주변 장치들 간의 소통을 위한 하드웨어와 프로토콜 표준으로 개발되었다. 전통적인 SCSI 프로토콜은 융통성이 뛰어나 어디에서난 사용된다.

USB 저장 장치와 통신을 위해 리눅스는 SCSI 프로토콜을 사용한다.

[root@was sda]# lsscsi </p>[0:0:0:0]&nbsp;&nbsp; disk &nbsp;&nbsp;&nbsp; ATA &nbsp;&nbsp; VBOX &nbsp;&nbsp;&nbsp;HARDDISK 1.0 &nbsp;&nbsp;&nbsp;/dev/sda

1.	[0:0:0:0] = 시스템상에 존재하는 장치의 주소다.
2.	disk = 장치의 종류가 어떤 것인지를 나타낸다
3.	/dev/sdaw = 장치 파일을 발견한 장소를 나타내고 있다.

리눅스는 드라이버들이 장치들을 접하게 되는 순서에 따라서 장치에 장치 파일들을 할당 한다.

위의 예제에 의하면 커널은 디스크를 먼저 발견하고, 옵티컬 드라이브 그 다음으로, 플래시 드라이브를 마지막으로 발견한 것이다.

이러한 장치 할당 방식은 전통적으로 하드웨어 변경할 때 문제를 일으켰다. 세 개의 디스크인 /dev/sda, /dev/sdb, /dev/sdc를 가진 시스템을 갖고 있다고 가정했을때, /dev/sdb가 깨져서 머신이 다시 동작 할 수 있도록 디스크를 제거해야 한다면, 이전의 /sdb/sdc는 /dev/sdb로 이동하게 된다. 그리고 더이상 /dev/sdc는 존재하지 않게 된다. /etc/fstab 파일에서 직접 장치 이름을 참조했다면 정상적으로 되돌리기 위해서 파일에 변경을 줘야 한다.

이문제를 해결하기 현재 리눅스 시스템은 지속적으로 디스크 드라이브에 접근 할 수 있도록 보편적 고유 식별자(UUID)를 사용한다.

###3.4.2 CD와 DVD 드라이브: /dev/sr\*

-	리눅스는 대부분의 옵티컬 장치 드라이브를 SCSI 드라이브 /dev/sr0, /dev/sr1 등으로 인식 한다.
-	오래된 인터페이의 경우 PATA 장치로 나타 날수 도 있다.
-	해당 장치는 오직 디스크로부터 읽는 용도라만 사용된다. 옵티컬 장치의 쓰기와 고쳐 쓰는 기능의 경우는 /dev/sg0처럼 "제네릭"SCSI 장치들을 사용한다.

###3.4.3 PATA 하드 디스크: /dev/hd\* + /dev/hda, /dev/hdb, /

dev/hdc와 /dev/hdd는 리눅스 커널의 오래된 버전들에서 흔히 볼 수 있다. 이들은 이터페이스 0과 1의 마스터 장치와 슬레이브 장치를 기초로 고정 할당된다.

###3.4.4 터미널: /dev/tty*, /dev/pts/*, dev/tty + 터미널은

사용자 프로세스와 I/O장치 간의 문자들을 옮기는 장치다.

-	의사 터미널 장치는 실제 터미널의 I/O 기능을 이해아는 모조 터미널이라고 할 수 있다.
-	실제 하드웨어의 일부분과 소통을 하는 것이 아니라 커널이 셸 터미널 윈도우처럼 소프트웨어 일부분에 I/O 인터페이스를 제시한다.

-	흔히 쓰이는 두가지 터미널 장치들은 /dev/tty1(첫 번째 가상 콘솔)과 /dev/pts/0(첫 번째 의사 터미널 장치)이다. /dev/pts 디렉터리는 전용 파일 시스템이다.

#### 디스플레이 모드와 가상콘솔

리눅스는 두개의 디스플레이 모드가 있다. 텍스트모드와 x윈도우 를 갖고 있다. 리눅스 시스템이 전통적으로 텍스트 모드에서 부팅된다고 하더라도 지금은 대부분의 배포판ㄷ르이 커널 매개 변수를 사용 하고 시스템이 부팅하고 있을때 텍스트 모드를 완전히 감추는 임시 그래픽 디스플레이 매커니즘을 사용한다.

리눅스는 ㄷ디스플레이를 다중 방식으로 제공하도록 가상 콘솔을 지원한다. 그래픽 또는 텍스트 모드로 실행한다. 텍스모드에서 키를 조합하여 콘솔 간에 전환 할 수있다 Alt-F1은 /dev/tty1으로 이동하고, Alt-F2 /dev/tty2등으로 이동한다.

가상서버가 그래픽모드로 가동한다면 일반적으로는 CTRL-Alt-Function 키 조합을 사용한다.

-	콘솔 전환에 문제가 발생한다면 chvt 명령으로 시스템이 콘솔을 변경하도록 시도 할 수 있다.

---

$ chvt 1

---

### 3.4.5 직렬포트: /dev/ttyS\*

오래된RS-232 타입이나 그와 유사한 직렬포트들은 특별한 터미널 장치라고 할 수 있다. 직렬포트 장치로는 명령줄에서 많은 것을 할수 없다. 보드속도(baud rate)와 흐름 제어 등 신경 써야 하는 설정들이 너무 많기 때문이다.

### 3.4.6 병렬포트:/dev/lp0와 /dev/lp1

단일 병렬포트 장치(주로 USB) /dev/lp0과 /dev/lp1은 윈도우즈에서 LPT1:과 LPT2:에 해당한다 여러분은 직접 cat 명령을 통해 파일들을 병렬 포트로 전송 할 수 있다. 하지만 프린터에 추가로 폼피드나 리셋을 부여해야 할 것이다. CUPS와 같은 프린터 서버는 프린터와의 상호 작용을 훨씬 더 잘 조절한다.

### 3.4.7 오디오 장치: /dev/snd/*, dev/dsp, /dev/audio 그외 장치들

리눅스는 두 가지 종류의 오디오 장치를 갖고 있다. 하나는 고급 리눅스 아키텍쳐 시스템 인터페이스를 위한 장치고, 다른 하나는 좀더 구식인 오픈 사운드 시스템을 위한 장치다. ALSA 장치는 /dev/snd 디렉터리에 위치한다 그러나 직접 이것들을 사용하기는 어렵다 ALSA를 사욯나는 리눅스 시스템은 만약 OSS 컨러이 현재 로딩 된다면OSS 호환이 간으한 장치를 지원한다.

### 3.4.8 장치 파일 만들기 현재 자체 장치 파일을 생성 하지 않는다. 드문 경우지만 네임드 파이프를 생성해야 할 수도 있다.

mknod 멸령은 장치를 생성한다. 우리는 주장치 번호와 부장치 번호뿐 아니라 장치 이름도 알아야 한다 /dev/sda1을 생성 하려면

---

root@host ~]# mknod /dev/sda1 b 8 2

---

b 8 2는 주장치 번호가 8이고 부장치 번호가 2인 블록 장치를 나타낸다. 문자 장치나 네임드 파이프 장치의 경우 b 대신에 c 또는 p를 사용한다.
mknod명령은 가끔 네임드 파이프를 생성하는 경우에만 융용하다 한때는 시스템복구 시 단일-사용자모드에서 잃어버린 장치들을 생성할 때 유용하게 사용했었다.

유닉스와 리눅스의 오랜된 버전에서 /dev 디렉터리를 유지하는 것은 일종의 도전이었다. 매번 중요한 커널 업그레이드나 드라이버를 추가하면서 커널은 더 많은 종류의 장치들을 지원할 수 있었다. 매번 중요한 커널 업그레이드나 드라이버를 추가하면서 커널은 더많은 종류의 장치들을 지원할 수 있었다. 즉 장치 파일 이름에 새로운 주번호와 부번호가 할당되었고, 이들을 유지하기가 어려웠다. 그래서 각 시스템 장치그룹들을 생성하기 우해 /dev MAKEDEV 프로그램을 보유했다. 시스템을 업그레이드 랫을때, 
MAKEDEV의 업데이트를 찾아서 새로운 장치를 생성하기 위해 실행하곤 했다.


### 3.5 udev 

복잡함은 불안정한 시스템을 야기할 수 있다. 장치파일 관리가 그런 예에 속한다. 우리들은 서로의 공간에서 장치 파일들을 생성할 수 있다 그런데 왜 커널에서 그일을 하려고 하는걸까?
리눅스 커털은 시스템에서 새로운 장치를 탐지하자마자 사용자 공간 프로세스에 알린다 다른 편의 사용자 공간 프로세스는 새로운 장치의 특징을 검토하고 새로운 파일을 만든 후 장치의 초기 설정을 수행한다. 

그것은 이런이다 그러나 안타깜게도 실제로 이런 접근 방식에는 문제가 있다. 장치 파일들은 부팅 과정 초기에 반드시 필요하다. 그래서 udev가 일찍 가동되어야 한다. 장파일들을 생성하기 위해서 udev는 생성되기로 예정되어 있는 어떤 장치에도 의존할 수가 없는 상황이 된다. 또한 시스템의 나머지요소들이 udev가 시작한느 것을 기다리는라 지연되지 않도록 초기 스타트업이 아주 빠르게 실행되어야 한다. 


###3.5.1 devtmpfs

devtmpfs 파일 시스템은 부팅 시에 장치 활ㅇ용 관한 문제에 대응하면서 발전된 시스템이다. 이 파일 시스템은 기존의 devfs가 지원하던 것과 유사하지만 단순화 된것이다 커널은 필요에 따라서 장치 파일들을 생성하고 새롱누 장치를 사용할 수 있다는 것을 udevd에 통지한다. 이 신호를 받으면 udevd는 장치 파일을 생성하지 않지만, 장치 초기 설정을 수행하고 프로세스에 통지한다. 
게다가 장치를 식별하도록 /dev에 많은 심볼릭 링크들을 생성한다. /dev/disk/by_id 디렉터리에서 이런  예들을 발견할 수 있는 것이다. 여기서 각각의 연결된 디스크는 하나 혹은 그 이상의 항목들을 가지고 있다.

udevd는 인터페이스 타입, 제조사와 모델 정보, 시리얼 번호, 그리고 파티션으로 링크의 이름을 명명한다. 그렇다면 udev는 어떤 심볼릭 링크가 생성될 것인지 그리고 얻허게 이들을 생성할 것인지 어떻게 알 수 있을까? 다음 절은 udev가 어떤 방식으로 작업에 수행 하는지 설명 하고 잇다. 그러나 이책의 진도를 이어나갈 때 이부분에 대해 꼭 알 필요는 없다 만약 리눅스장치를 이번에 처음으로 경험하는 것이라면 다음 장으로 옮겨서 디스크 사용법에 대해서 학습하도록 권장한다. 


### 3.5.2 udevd 운영과 설정

udevd 데몬은 다으모가 같이 동작한다.

 1. 커널은 udev로 내부 네트워크 링크를 통해서 uevent라고 불리는 알림 이벤트를 전송한다. 
 2. udevd는 uevent 안의 모든 속성들을 로딩한다. 
 3. udevd는 그 규칙들을 분석하고 조치를 취하거나 그 규칙들을 기반으로 더 많은 속성들을 설정한다. 


### 3.6 SCSI와 리눅스 커널에 대한 상세 분석

전통적인 SCSI 하드웨어 구성은 버스를 통해 여러 장치들이 연결된 호스트 어댑터다. 호스트 어댑터는 컴퓨터에 연결된다. 호스트 어댑터와 장치들은 가각 SCSI ID를 갖고 있다. 그리고 SCSI 버전에 따라서 버스당 ID가 8개일 수도 있고 16개일 수도 있다. SCSI타킷이라는 용어가 장치와 SCSI ID를 나타내는 데 사용되는 것을 볼 수 있을 것이다. 

호스트 어댑터는 피어-투피어 관계로 SCSI 명령 집합을 통해 장치와 소통하낟 장치들은 호스트 어댑터로 반응을 전송한다. 컴퓨터는 직접 장치 사슬에 연결되지 않기 때문에 디스크와 다른 장치들과 소통을 하려면 호스트 어댑터를 통해야 한다. 일반적으로 컴퓨터는 장치로 SCSI 명령을 전달하기 우해서 호스트 어댑터로 전송한다. 그리고 장치는 호스트 어댑터로 반응들을 다시 전달한다.

Serial Attached SCSI와 같은 SCSI의새로운 버전들은 아주 뛰어난 기능을 제공한다. 대부분의 머신에서 SCSI 장치들을 찾을 수 없을 것이다. 대신 SCSI명령을 사용하는 USB저장 장치를 훨씬 더 자주 보게 될 것이다. 게다가 ATAPI를 지원하는 장치들은 SCSI 집합의 한 버전을 사용한다. 

SATA 디스크 역시 libata의 번역 계층을 통해 SCSI 장치로 시스템상에 나타난다 일부 SATA 컨트롤러는 하드에워에서 이런 번역을 실행한다. 

상위와 하위 레이어는 여러 가지 종류의 드라이버들을 포함하고 있다. 하지만 시스템상에 어떤 장치 파일이 주어지든지 커널은 하나의 사우이 레이어 드라이버와 하나의 하위 레이어 드라이버와 하나의 하위 레이어 드라이버를 사용한다는 점이 중요하다. /dev/sda의 디스크의 경우도 커널이 sd 상위 레이어 드랑비와 ATA브리지 하위 레이어 드라이버를 사용하고 있다.

한 개의 하드웨어 장치를 위하여 한 개 이상의 상위 레이어 드라이버를 사용해야 할 때도 있다 SCSI호스트 어댑터나 하드웨어 RAID 컨트롤러에 연결된 디스크처럼 실제 하드웨어 SCSI 장치들의 경우, 하위 레이어 드라이버는 직접 그 아랭의 하드웨어와 소통한다. 그러나 SCSI 서브시스템에 연결된 대부분의 하드웨어의 경우는 다르게 접근한다. 

### 3.6.1 USB저장 장치와 SCSI

SCSI드라이버보다 더 많은 것을 필요로 한다. /dev/sdf로 표현되는 USB플래시 드라이버는 SCSI명령을 이해한다. 하지만 드라이버와 실제로 소통을 하려면 커널이 USB 시스템을 통해 소통하는 방법을 알아야 한다.

대략적으로 USB는 SCSI와 매우 유사하다. USB는 장치 클래스, 버스와 호스트 컨트롤러를 갖고 있다. 그래서 리눅스 커널이 SCSI 서브시스템과 아주 유사한 3단 레이어 USB서브시스템을 포함하는 것은 놀라운 일도 아니다. -상위에 장치 클래스 드라이버, 중간에 버스 관리 코어, 하위에 호스트 컨트롤러 드라이버를 갖추고 있는 시스템이다. SCSI 서브시스템은 그 요소 간에 USB 메시지를 전달한다. 게다가 lsscsi와 유사한 lsusb 명령도 있다.

여기서 정말 흥미로운 부분은 상위 레이어의 USB 저장장치 드라이버다. 이 드라이버는 번역기처럼 동작한다. 드라이버가 한쪽으로 SCSI에 말을 전하고, 다른쪽으로 USB에 말을 전한다. 저장 장치 하드웨어는 USB 메시지 내부에 SCSI 명령을 포함하고 있기 때문에 드라이버는 비교적 작업 수행이 쉽다. 대부분 데이터를 다시 가공하는 일이다. 

SCSI와 USB 서브 시스템이 제대로 준비가 되면 플래시 드라이브와 대화하는데 필요한 모든 것이 거의 갖춰진 것이라고 할 수있다. 마지막으로 필요한 부분은 SCSI 서브시스템에 있는 하위 레이어 드라이버인데, 이는 US 저장 장치 드라이버가 USB 서브시스템의 일부이지 SCSI 서브시스템의 일부가 아니기 때문이다. 서브시스템이 다른 서브시스템이 다른 서브 시스템과 대화를 하도록 만들기 위해서 간다한 하위 레이어 SCSI 브리지 드라이버가 USB 서브 시스템의저장 장치를 드라이버로 연결한다. 

### 3.6.2 SCSI와 ATA

SATA 하드 디스크와 옵티컬 드랑비ㅡ는 모두 동일하게 SATA 인터페이스를 사욯난 커널의 SATA전용 드라이버를 SCSI 서브시스템에 연결하기 위해 커널은 USB드라이버들처럼 브리지 드라이버를 활용한다. 그러나 구조가 드라고 복잡한 문제가 동반된다. 옵티컬 드라이브는 ATA 프로토콜로 인코딩된 SCSI명령어의 한 버전인 ATAPI로 소통한다 그러나 하드 디스크는 ATAPI를 사용하지 않고 어떤 SCSI 명령어도 인코딩하지 않는다.

리눅스 커널은 SATA드라이브를 SCSI 서브시슽ㅁ과 조화시키는 데 libata라고 불리는 라이브러리의 일부를 사용한다. APTAPI를 사용하는 옵티컬 드라이브의 경우, 이것은 SCSI의 명령을 ATA프로토콜로 포장하고 그 프로토콜로 추출하는 비교적 간단한 작업이다. 그러나 하드 디스크의 경우는 라이브러리가 전체 명령을 번역해야 하기 때무넹 작업이 훨씬 더 복잡하다.

옵티컬 드라이버의 작업은 영어 책을 커퓨터에 입력하느 것과 유사하다. 이작을 하는데 책의 내용을 이해할 필요는 없다. 심지어 영어를 알지 못해도 입력하는 데 문제는 없다. 그러나 하드 디스크를 위한 작업은 독일어 책을 읽고 그것을 영어로 번역해서 컴퓨터에 입력하는 것과 유사하다. 이런 경우 두 가지 언어를 잘 알아야 할 뿐만 아니라 책의 내용도 이해해야 한다.

### 3.6.3 제네릭(일반) SCSI 장치

사용자 곤간 프로스세가 SCSI 서브시스템과 소토할 때 일반적으로 블록 장치 레이어 또는 SCSI자치 클래스 드라이버의 맨 위에 자리하는 다른 커널 장치를 통해서 소통한다. 달리해서 대부분의 사용자 프로세스는 SCSI장치나 SCSI 명령들에 대해서 어떤것도 알 필요가 없다. 

그러나 사용자 프로세스는 장치 클래스 드라이버를 우회할 수 있고, SCSI 프로토콜 명령을 제네릭 장치들을 통해서 직접 장치에 전달할 수 있다.
작업이 더 복잡해짐에 따라 커널에서는 이들을 제외시키는 편이 낫다. CD/DVD 쓰기와 일기에 대하여 생각해보자. 읽는 것보다 기록하는 것이 훨씬 더 어려울 뿐만 아니라, 중요한 시스템 서비스들은 쓰기 동작에 의존하지 않는다. 사요자 공간 프로그램은 커널 서비스보다 약간 비효율적으로 기록 작업을 수행할 것이다. 그러나 사용자 공간 프로그램이 커널 서비스보다 구축하고 유지하기 훨씬 더 쉬울 것이다. 그러나 사요자 공간 프로그램이 커널 서비스보다 구축하고 유지하기 훨씬 더 쉬울것이다. 그리고 오류가 커널 공간을 위협하지도 않는다. 그러므로 리눅스에서 옵티컬 디스에 리고하려면 /dev/sg1과 같은 제네릭  SCSI 장치와 소통하는 프로그램을 실행하게 된다. 그러나 기록 작업과 비교해서 상대적으로 읽는 것이 더 단순하기 때문에 여전히 커널에서는 전요 sr 옵티컬 장치드라이버를 사요하여 장치로부터 읽는 작업을 한다. 


### 3.6.4 하나의 장치에 대한 다중 접근 방법

사요작 공간으로부터 옵티컬 드라이브를 접속하기 위한 두개의 접속점이 표시되어 있다. 프로세스 A는 드라이버로부터 sr 드라이버를 사용하여 읽는다. 그리고 프로세스B는 sg 드라이버를 사용하여 드라이브에 기록한다. 그러나 이와 같은 프로세스들은 보통 동일한 장치에 접속하기 위해서 동시에 실행되지 않는다. 




